##                                       常见排序算法

### ![1552829783415](C:\Users\WinJX\AppData\Roaming\Typora\typora-user-images\1552829783415.png)    



## 1 . 冒泡排序

![img](https://ask.qcloudimg.com/http-save/yehe-1733635/9prhem3ope.gif)

```python
'''冒泡排序'''
def bubble_sort(nums):
    for i in range(len(nums)-1):
        target = True
        for j in range(len(nums)-i-1):
            if nums[j] > nums[j+1]:
                nums[j],nums[j+1] = nums[j+1],nums[j]
                target = False
        if target:
            break
    return nums
```



## 2 . 选择排序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

```python
'''选择排序'''

def select_sort(nums):
    for i in range(len(nums)-1):
        min_index = i
        for j in range(i+1,len(nums)):
            if nums[j] < nums[min_index]:
                min_index = j
        if min_index != i:
            nums[i],nums[min_index] = nums[min_index],nums[i]
    return nums	
```



## 3 . 插入排序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

```python
'''插入排序'''

def insert_sort(nums):
    for i in range(1,len(nums)):
        for j in range(i,0,-1):
            if nums[j] < nums[j-1]:
                nums[j],nums[j-1] = nums[j-1],nums[j]
    return nums
```



## 4 . 快速排序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

```python
'''快速排序'''

def quick_sort(lst,left,right):
    if left > right:
        return lst
    pivot = lst[left]
    start = left
    end = right
    while start < end:
        while start < end and pivot < lst[end]:
            end -= 1
        lst[start] = lst[end]
        while start < end and pivot > lst[start]:
            start += 1
        lst[end] = lst[start]
    lst[start] = pivot
    quick_sort(lst,left,start-1)
    quick_sort(lst,start+1,right)
    return lst
```



## 5 . 合并排序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif)

```python
'''合并排序'''

def merge_sort(nums):
    if len(nums) <= 1:
        return nums
    else:
        mid = len(nums)//2
        nums_l = merge_sort(nums[:mid])
        nums_r = merge_sort(nums[mid:])
    return merge(nums_l,nums_r)

def merge(left,right):
    l,r = 0,0
    rst = []
    while l < len(left) and r < len(right):
        if left[l] <= right[r]:
            rst.append(left[l])
            l += 1
        else:
            rst.append(right[r])
            r += 1
    rst += left[l:]
    rst += right[r:]
    return rst
```



## 6 . 希尔排序

![img](https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif)

```python
'''希尔排序'''

def shell_sort(nums):
    gap = len(nums)//2
    while gap > 0:
        for i in range(gap,len(nums)):
            while i-gap >= 0 and nums[i] < nums[i-gap]:
                nums[i],nums[i-gap] = nums[i-gap],nums[i]
                i -= gap
        gap = gap//2
    return nums
```



## 7 . 堆排序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif)

```python
def sift(nums, parent, length):
    child = 2 * parent + 1     #左子节点索引
    temp = nums[parent]        # 保存父节点值
    while child <= length:    
                               #存在右子节点且值比左子节点值大
        if child < length and nums[child] < nums[child+1]:  
            child += 1         #将索引指向值大的子节点
        if temp > nums[child]: #如果父节点的值大，则跳出
            break
        else:                
            nums[parent] = nums[child]   # 将父节点替换成新的子节点（值大的那个）的值
            parent = child               # 变成新的父节点
            child = 2 * parent + 1       # 新的子节点
    nums[parent] = temp        # 将替换的父节点值赋给最终的父节点


def heap_sort(nums):
    n = len(nums)
    # 创建堆
    for i in range(n//2-1, -1, -1):
        sift(nums, i, n-1)

    # 挨个出数
    for i in range(n-1, -1, -1):    # 从大到小
        nums[0], nums[i] = nums[i], nums[0]     # 将最后一个值与父节点交互位置
        sift(nums, 0, i-1)
    return nums
```

